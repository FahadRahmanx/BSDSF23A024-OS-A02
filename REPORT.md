Q1. What is the crucial difference between the stat() and lstat() system calls? In the context of the ls command, when is it more appropriate to use lstat()?
The main difference between stat() and lstat() is that stat() retrieves information about the actual file a symbolic link points to, whereas lstat() provides details about the link itself. In the ls command, lstat() is preferred when displaying information about symbolic links without following them, ensuring they appear as separate entities rather than as their target files

Q2. The st_mode field in struct stat is an integer that contains both the file type (e.g., regular file, directory) and the permission bits. Explain how you can use bitwise operators (like &) and predefined macros (like S_IFDIR or S_IRUSR) to extract this information.
The st_mode field in struct stat combines both file type and permission data. Using bitwise operators and predefined macros like S_IFDIR or S_IRUSR, specific attributes can be extracted to identify the file type and access permissions. This enables commands like ls -l to correctly interpret and display each file’s type and permission settings

Q3. Explain the general logic for printing items in a "down then across" columnar format. Why is a simple single loop through the list of filenames insufficient for this task?
In a “down then across” format, filenames fill columns vertically before moving to the next column. A single loop can’t achieve this since it prints items in one line. Instead, nested loops are used, where each item’s position is calculated using col * num_rows + row to print files in properly aligned columns

Q4. What is the purpose of the ioctl system call in this context? What would be the limitations of your program if you only used a fixed-width fallback (e.g., 80 columns) instead of detecting the terminal size?
In this context, the ioctl system call is used to query the terminal for its current width, allowing the program to adjust the number of columns dynamically based on the actual screen size. This ensures filenames are displayed neatly and efficiently, without overflowing or leaving too much unused space. If the program relied only on a fixed-width fallback, it wouldn’t adapt to different terminal sizes  and on wider screens it would waste space, and on smaller ones, filenames could wrap or misalign

Q5. Compare the implementation complexity of the "down then across" (vertical) printing logic versus the "across" (horizontal) printing logic. Which one requires more pre-calculation and why?
The “down then across” (vertical) printing logic is more complex because it requires pre-calculating both the number of columns and rows to correctly map each filename’s position using index arithmetic. It also needs careful alignment so items appear in the right column order. In contrast, the “across” (horizontal) method is simpler—it only tracks the current line width and moves to a new line when reaching the terminal limit, without needing to compute rows or rearrange indices

Q6. Describe the strategy you used in your code to manage the different display modes (-l, -x, and default). How did your program decide which function to call for printing?
The program uses a display mode flag to manage the different options. During argument parsing with getopt(), the -l flag sets the mode to long listing, the -x flag sets it to horizontal display, and the default mode is the standard vertical (down-then-across) display. After reading all filenames, the program checks this flag’s value—if it’s set to long mode, it calls do_ls_long(), if set to horizontal mode, it calls the new horizontal display function, and otherwise, it calls the default do_ls() function. This simple flag-based strategy keeps the code organized and makes switching between display modes easy

Q7. Why is it necessary to read all directory entries into memory before you can sort them? What are the potential drawbacks of this approach for directories containing millions of files?
Reading all directory entries into memory is necessary because sorting requires access to the entire list of filenames at once; you can’t correctly order items without knowing all of them first. However, this approach can become inefficient or even problematic for very large directories containing millions of files, as it consumes a significant amount of memory and processing time. In extreme cases, it could lead to slow performance, high memory usage, or even program crashes due to insufficient system resources

Q8. Explain the purpose and signature of the comparison function required by qsort(). How does it work, and why must it take const void * arguments?
The comparison function in qsort defines how two elements are ordered during sorting. It returns a negative, zero, or positive value depending on whether the first element should come before, is equal to, or comes after the second. It uses const void * arguments because qsort is a generic function that can sort any data type, and these pointers must be cast to the correct type within the function. This approach makes the sorting mechanism flexible and reusable for different kinds of data
